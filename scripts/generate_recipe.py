import os
import openai
import random
import logging
from typing import Dict, Any
from dotenv import load_dotenv

# Configuration du logging
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
load_dotenv()

# Configuration OpenAI
openai.api_key = os.getenv('OPENAI_API_KEY')

# Configuration OpenAI
client = openai.OpenAI(api_key='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')

def escape_sql_string(s: str) -> str:
    """√âchappe une cha√Æne de caract√®res pour le SQL"""
    if s is None:
        return 'NULL'
    return "'" + str(s).replace("'", "''") + "'"

def generate_with_ai(prompt: str) -> str:
    """G√©n√®re du texte avec l'API OpenAI."""
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "Tu es un chef cuisinier expert qui aide √† g√©n√©rer des recettes d√©taill√©es."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logger.error(f"Erreur lors de l'appel √† OpenAI: {str(e)}")
        raise

def validate_recipe_data(data: Dict[str, Any]) -> bool:
    """Valide les donn√©es de la recette g√©n√©r√©e."""
    required_fields = {
        'recipe': ['title', 'country', 'region', 'description', 'preparation_time', 
                  'cooking_time', 'difficulty', 'servings', 'is_premium', 'image_url'],
        'ingredients': ['name', 'quantity', 'unit'],
        'steps': ['order_number', 'title', 'description'],
        'playlist': ['title', 'description', 'spotify_link'],
        'wine_pairing': ['name', 'description', 'region']
    }
    
    try:
        # V√©rifier la recette
        for field in required_fields['recipe']:
            if field not in data['recipe']:
                logger.error(f"‚ùå Champ manquant dans recipe: {field}")
                return False
        
        # V√©rifier les ingr√©dients
        if not data['ingredients']:
            logger.error("‚ùå Aucun ingr√©dient trouv√©")
            return False
        for ingredient in data['ingredients']:
            for field in required_fields['ingredients']:
                if field not in ingredient:
                    logger.error(f"‚ùå Champ manquant dans ingredient: {field}")
                    return False
        
        # V√©rifier les √©tapes
        if not data['steps']:
            logger.error("‚ùå Aucune √©tape trouv√©e")
            return False
        for step in data['steps']:
            for field in required_fields['steps']:
                if field not in step:
                    logger.error(f"‚ùå Champ manquant dans step: {field}")
                    return False
        
        # V√©rifier la playlist
        for field in required_fields['playlist']:
            if field not in data['playlist']:
                logger.error(f"‚ùå Champ manquant dans playlist: {field}")
                return False
        
        # V√©rifier l'accord de vin
        for field in required_fields['wine_pairing']:
            if field not in data['wine_pairing']:
                logger.error(f"‚ùå Champ manquant dans wine_pairing: {field}")
                return False
        
        return True
    except Exception as e:
        logger.error(f"‚ùå Erreur lors de la validation: {str(e)}")
        return False

def generate_recipe(recipe_name: str) -> dict:
    """G√©n√®re une recette compl√®te avec toutes les informations associ√©es."""
    try:
        logger.info(f"üîÑ D√©but de la g√©n√©ration pour: {recipe_name}")
        
        # D'abord, d√©terminons l'origine de la recette
        logger.info("üìç G√©n√©ration de l'origine...")
        origin_prompt = f"""Pour la recette {recipe_name}, donne-moi uniquement le pays d'origine dans ce format :
Pays: [nom du pays]"""
        
        origin_response = generate_with_ai(origin_prompt)
        country = origin_response.split("Pays:")[1].strip() if "Pays:" in origin_response else "Non sp√©cifi√©"
        logger.info(f"‚úÖ Origine d√©termin√©e: {country}")
        
        # Cr√©ation du personnage et de son univers
        character_prompt = f"""Pour une recette de {country}, cr√©e un personnage de chef cuisinier et son univers avec ces d√©tails pr√©cis :
Nom: [pr√©nom et nom typiques du pays]
√Çge: [√¢ge]
Ville: [ville du pays]
Restaurant: [nom et description de son √©tablissement]
Histoire personnelle: [histoire riche du chef, ses motivations, sa famille]
Caract√®re: [traits de personnalit√© qui le rendent unique]
Philosophie culinaire: [sa vision de la cuisine]
Routine quotidienne: [description d'une journ√©e type]"""

        character_info = generate_with_ai(character_prompt).split('\n')

        # Cr√©ation de l'histoire immersive
        story_prompt = f"""Cr√©e une histoire immersive et d√©taill√©e autour de la pr√©paration de {recipe_name} avec notre chef comme personnage principal. L'histoire doit √™tre une narration riche qui :

1. D√©crit l'ambiance du restaurant/du lieu de pr√©paration
2. Pr√©sente le chef et sa connexion personnelle avec cette recette
3. Explique l'importance culturelle et historique du plat
4. D√©crit les ingr√©dients et leur signification
5. Termine sur une note √©motionnelle ou culturelle

L'histoire doit inclure :
- Des descriptions sensorielles d√©taill√©es (odeurs, sons, textures)
- Des dialogues naturels et authentiques
- Des r√©f√©rences culturelles et historiques
- Des anecdotes personnelles du chef
- Des d√©tails sur les techniques traditionnelles

Format requis :
[Histoire narrative continue, environ 4-5 paragraphes d√©taill√©s]"""

        story = generate_with_ai(story_prompt)

        # √âtapes avec le personnage adapt√©
        steps_prompt = f"""En suivant l'histoire de notre chef pour la recette {recipe_name}, cr√©e des √©tapes d√©taill√©es et narratives. Chaque √©tape doit √™tre une sc√®ne compl√®te et riche qui :

1. D√©crit l'action technique pr√©cise avec des d√©tails sur les gestes et les mouvements
2. Inclut des conseils du chef bas√©s sur son exp√©rience
3. Explique l'importance de l'√©tape dans la tradition culinaire
4. Ajoute des d√©tails sensoriels (odeurs, textures, sons)
5. Int√®gre des anecdotes personnelles ou culturelles
6. D√©crit les r√©actions et les √©motions du chef

Format pour chaque √©tape (minimum 3-4 phrases par √©tape) :
√âtape 1: [Description technique d√©taill√©e avec gestes pr√©cis] [Conseils du chef avec explications] [Importance culturelle] [D√©tails sensoriels] [Anecdotes personnelles]
√âtape 2: [Description technique d√©taill√©e avec gestes pr√©cis] [Conseils du chef avec explications] [Importance culturelle] [D√©tails sensoriels] [Anecdotes personnelles]
etc.

Utilise ce personnage et son univers :
{character_info}

L'histoire principale :
{story}"""

        # Modification du general_prompt pour une description plus riche
        general_prompt = f"""Pour la recette {recipe_name}, en utilisant notre personnage et son histoire :
{character_info}

Format requis :
Pays: {country}
Region: [nom de la r√©gion]
Description: [Description riche et d√©taill√©e qui inclut :
- L'histoire du plat dans la r√©gion
- La signification culturelle
- Les traditions associ√©es
- Les ingr√©dients embl√©matiques
- L'importance dans la cuisine locale]
Temps de pr√©paration: [X] min
Temps de cuisson: [X] min
Difficult√©: [facile/moyen/difficile]
Portions: [nombre]"""
        
        general_info = generate_with_ai(general_prompt).split('\n')
        
        # V√©rification et extraction s√©curis√©e des donn√©es
        def extract_value(lines, key):
            for line in lines:
                if line.startswith(f"{key}:"):
                    return line.split(":", 1)[1].strip()
            return None

        title = recipe_name
        region = extract_value(general_info, "Region") or "Non sp√©cifi√©"
        description = extract_value(general_info, "Description") or "Pas de description"
        
        try:
            prep_time = int(extract_value(general_info, "Temps de pr√©paration").replace(" min", ""))
        except (ValueError, AttributeError):
            prep_time = 30  # Valeur par d√©faut
        
        try:
            cook_time = int(extract_value(general_info, "Temps de cuisson").replace(" min", ""))
        except (ValueError, AttributeError):
            cook_time = 45  # Valeur par d√©faut
        
        difficulty = extract_value(general_info, "Difficult√©") or "moyen"
        
        try:
            servings = int(extract_value(general_info, "Portions"))
        except (ValueError, AttributeError):
            servings = 4  # Valeur par d√©faut

        # Ingr√©dients
        logger.info("ü•ï G√©n√©ration des ingr√©dients...")
        ingredients_prompt = f"""Pour la recette {recipe_name}, donne les ingr√©dients dans ce format pr√©cis :
[quantit√©] [unit√©] [ingr√©dient]
Par exemple:
300 g farine
2 unit√© oeufs
etc."""
        ingredients = generate_with_ai(ingredients_prompt).split('\n')
        ingredients = [i.strip('- ') for i in ingredients if i.strip('- ')]
        logger.info(f"‚úÖ {len(ingredients)} ingr√©dients g√©n√©r√©s")
        
        # √âtapes avec le personnage adapt√©
        steps = generate_with_ai(steps_prompt).split('\n')
        steps = [s.strip('123456789. ') for s in steps if s.strip('123456789. ')]
        logger.info(f"‚úÖ {len(steps)} √©tapes g√©n√©r√©es")
        
        # Playlist
        logger.info("üéµ G√©n√©ration de la playlist...")
        playlist_prompt = f"""Pour la recette {recipe_name}, propose une playlist dans ce format pr√©cis :
Titre: [nom de la playlist]
Description: [ambiance de la playlist]
Lien: spotify:playlist:[code]"""
        playlist = generate_with_ai(playlist_prompt).split('\n')
        logger.info("‚úÖ Playlist g√©n√©r√©e")
        
        # Accord de vin
        logger.info("üç∑ G√©n√©ration de l'accord de vin...")
        wine_prompt = f"""Pour la recette {recipe_name}, propose un accord de vin dans ce format pr√©cis :
Nom: [nom du vin]
Description: [description de l'accord]"""
        wine = generate_with_ai(wine_prompt).split('\n')
        logger.info("‚úÖ Accord de vin g√©n√©r√©")
        
        # Construction du r√©sultat
        recipe_data = {
            'recipe': {
                'title': recipe_name,
                'country': country,
                'region': region,
                'description': description,
                'preparation_time': prep_time,
                'cooking_time': cook_time,
                'difficulty': difficulty,
                'servings': servings,
                'is_premium': True,
                'image_url': f'https://source.unsplash.com/800x600/?{recipe_name.replace(" ", "%20")}',
                'latitude': round(random.uniform(-90, 90), 4),
                'longitude': round(random.uniform(-180, 180), 4),
                'story_intro': f"D√©couvrez la recette de {recipe_name}, inspir√©e des traditions culinaires de {region}. Pr√©parez-vous √† un voyage gustatif authentique.",
                'story_intro_audio_url': f"https://savorista.com/audio/stories/{recipe_name.replace(' ', '_').lower()}_intro.mp3"
            },
            'ingredients': [
                {
                    'name': ingredient.split(' ', 2)[-1],
                    'quantity': ingredient.split(' ')[0],
                    'unit': ingredient.split(' ')[1] if len(ingredient.split(' ')) > 2 else ''
                }
                for ingredient in ingredients
            ],
            'steps': [
                {
                    'order_number': i + 1,
                    'title': f'√âtape {i + 1}',
                    'description': step,
                    'story_content': step,
                    'story_audio_url': f"https://savorista.com/audio/stories/{recipe_name.replace(' ', '_').lower()}_step{i+1}.mp3",
                    'story_background_image_url': f"https://source.unsplash.com/800x600/?{recipe_name.replace(' ', '%20')},{i+1}"
                }
                for i, step in enumerate(steps)
            ],
            'playlist': {
                'title': playlist[0].split(': ')[1] if len(playlist) > 0 and ': ' in playlist[0] else "Ambiance culinaire",
                'description': playlist[1].split(': ')[1] if len(playlist) > 1 and ': ' in playlist[1] else "Une s√©lection musicale pour accompagner votre cuisine",
                'spotify_link': playlist[2].split(': ')[1] if len(playlist) > 2 and ': ' in playlist[2] else "spotify:playlist:37i9dQZF1DXb9LIXaj5WhZ",
                'image_url': 'https://source.unsplash.com/800x600/?music'
            },
            'wine_pairing': {
                'name': wine[0].split(': ')[1] if len(wine) > 0 and ': ' in wine[0] else "Vin recommand√©",
                'description': wine[1].split(': ')[1] if len(wine) > 1 and ': ' in wine[1] else "Un vin qui se marie parfaitement avec ce plat",
                'region': region,
                'image_url': 'https://source.unsplash.com/800x600/?wine'
            }
        }
        
        # Validation des donn√©es
        logger.info("üîç Validation des donn√©es g√©n√©r√©es...")
        if not validate_recipe_data(recipe_data):
            raise ValueError("Les donn√©es g√©n√©r√©es sont invalides")
        
        logger.info("üéâ G√©n√©ration termin√©e avec succ√®s")
        return recipe_data
        
    except Exception as e:
        logger.error(f"‚ùå Erreur lors de la g√©n√©ration: {str(e)}")
        raise
